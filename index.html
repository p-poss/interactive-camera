<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patrick Poss â€” Camera Effects</title>
    <meta name="description" content="Interactive real-time camera effects and filters. Apply aura, thermal, glitch, pixelate, edge detection, ASCII, and kaleidoscope effects to your webcam feed with customizable settings.">
    <meta name="keywords" content="camera effects, webcam filters, real-time video effects, interactive camera, visual effects, video filters, web camera, creative tools">
    <meta name="author" content="Patrick Poss">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="Patrick Poss â€” Camera Effects">
    <meta property="og:description" content="Interactive real-time camera effects and filters. Apply stunning visual effects to your webcam feed.">
    <meta property="og:url" content="https://interactive-camera.vercel.app">

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Patrick Poss â€” Camera Effects">
    <meta name="twitter:description" content="Interactive real-time camera effects and filters. Apply stunning visual effects to your webcam feed.">

    <!-- Additional SEO -->
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://interactive-camera.vercel.app">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ“¹</text></svg>">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --glass-bg: rgba(255, 255, 255, 0.12);
            --glass-bg-hover: rgba(255, 255, 255, 0.18);
            --glass-border: rgba(255, 255, 255, 0.2);
            --glass-highlight: rgba(255, 255, 255, 0.4);
            --glass-shadow: rgba(0, 0, 0, 0.25);
            --text-primary: rgba(255, 255, 255, 0.95);
            --text-secondary: rgba(255, 255, 255, 0.7);
            --text-tertiary: rgba(255, 255, 255, 0.5);
            --accent-blue: #007AFF;
            --radius-sm: 12px;
            --radius-md: 20px;
            --radius-lg: 28px;
            --radius-xl: 36px;
            --radius-pill: 100px;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Inter', 'SF Pro Display', sans-serif;
            background: #000;
            min-height: 100vh;
            overflow: hidden;
            color: var(--text-primary);
            -webkit-font-smoothing: antialiased;
        }

        /* Fullscreen video background */
        .video-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 0;
            overflow: hidden;
        }

        #video-feed {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            display: none;
            position: absolute;
            top: 0;
            left: 0;
        }

        #canvas-output {
            width: 100%;
            height: 100%;
            object-fit: cover;
            position: absolute;
            top: 0;
            left: 0;
        }

        /* Start button - centered */
        .start-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 200;
            pointer-events: none;
        }

        .start-container.hidden {
            display: none;
        }

        .btn-start {
            background: var(--glass-bg);
            backdrop-filter: blur(60px) saturate(200%);
            -webkit-backdrop-filter: blur(60px) saturate(200%);
            border: 1px solid var(--glass-border);
            color: var(--text-primary);
            width: 200px;
            height: 200px;
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 600;
            border-radius: 50%;
            cursor: grab;
            transition: box-shadow 0.3s, background 0.3s;
            box-shadow: 
                0 8px 32px var(--glass-shadow),
                inset 0 1px 0 var(--glass-highlight),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            overflow: hidden;
            pointer-events: auto;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            gap: 12px;
            user-select: none;
            touch-action: none;
        }

        .btn-start:active {
            cursor: grabbing;
        }

        .btn-start.dragging {
            cursor: grabbing;
            box-shadow: 
                0 16px 48px var(--glass-shadow),
                inset 0 1px 0 var(--glass-highlight),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
        }

        .btn-start::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 50%;
            background: linear-gradient(to bottom, rgba(255,255,255,0.1), transparent);
            border-radius: 50% 50% 0 0;
            pointer-events: none;
        }

        .btn-start:hover {
            background: var(--glass-bg-hover);
            box-shadow: 
                0 12px 48px var(--glass-shadow),
                inset 0 1px 0 var(--glass-highlight),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
        }

        .btn-start svg {
            width: 32px;
            height: 32px;
            fill: currentColor;
        }

        /* Liquid Glass Control Panel */
        .control-panel {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
        }

        /* Expanded panel content */
        .panel-expanded {
            background: var(--glass-bg);
            backdrop-filter: blur(60px) saturate(200%);
            -webkit-backdrop-filter: blur(60px) saturate(200%);
            border-radius: var(--radius-xl);
            border: 1px solid var(--glass-border);
            box-shadow: 
                0 24px 80px var(--glass-shadow),
                0 8px 32px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 var(--glass-highlight),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
            padding: 24px;
            width: 380px;
            max-height: 70vh;
            overflow-y: auto;
            overflow-x: hidden;
            scrollbar-width: none;
            opacity: 0;
            transform: translateY(20px) scale(0.95);
            pointer-events: none;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        .panel-expanded::-webkit-scrollbar {
            display: none;
        }

        .panel-expanded::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--glass-highlight), transparent);
        }

        .panel-expanded.open {
            opacity: 1;
            transform: translateY(0) scale(1);
            pointer-events: auto;
        }

        /* Collapsed pill bar */
        .panel-collapsed {
            background: var(--glass-bg);
            backdrop-filter: blur(60px) saturate(200%);
            -webkit-backdrop-filter: blur(60px) saturate(200%);
            border-radius: var(--radius-pill);
            border: 1px solid var(--glass-border);
            box-shadow: 
                0 8px 32px var(--glass-shadow),
                inset 0 1px 0 var(--glass-highlight);
            padding: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .panel-collapsed:hover {
            background: var(--glass-bg-hover);
        }

        .pill-btn {
            width: 48px;
            height: 48px;
            background: transparent;
            border: none;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            color: var(--text-secondary);
        }

        .pill-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            color: var(--text-primary);
        }

        .pill-btn.active {
            background: var(--accent-blue);
            color: white;
            box-shadow: 0 4px 12px rgba(0, 122, 255, 0.4);
        }

        .pill-btn svg {
            width: 24px;
            height: 24px;
            stroke: currentColor;
            stroke-width: 1.5;
            fill: none;
        }

        .pill-btn.capture-btn svg {
            fill: currentColor;
            stroke: none;
        }

        .expand-btn {
            width: 48px;
            height: 48px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            color: var(--text-secondary);
        }

        .expand-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            color: var(--text-primary);
        }

        .expand-btn svg {
            width: 20px;
            height: 20px;
            stroke: currentColor;
            stroke-width: 2;
            fill: none;
            transition: transform 0.3s ease;
        }

        .expand-btn.open svg {
            transform: rotate(180deg);
        }

        /* Panel sections */
        .panel-section {
            margin-bottom: 24px;
        }

        .panel-section:last-child {
            margin-bottom: 0;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .section-title {
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-tertiary);
        }

        .section-value {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--accent-blue);
        }

        /* Effect grid */
        .effect-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }

        .effect-btn {
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid transparent;
            border-radius: var(--radius-md);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            color: var(--text-secondary);
            font-family: inherit;
            font-size: 0.65rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.04em;
        }

        .effect-btn svg {
            width: 22px;
            height: 22px;
            stroke: currentColor;
            stroke-width: 1.5;
            fill: none;
        }

        .effect-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            color: var(--text-primary);
        }

        .effect-btn.active {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
            box-shadow: 0 4px 16px rgba(0, 122, 255, 0.4);
        }

        /* Sliders */
        .slider-group {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .slider-item {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .slider-label {
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text-primary);
        }

        .slider-value {
            font-size: 0.85rem;
            color: var(--accent-blue);
            font-weight: 600;
            font-variant-numeric: tabular-nums;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 
                0 2px 8px rgba(0, 0, 0, 0.3),
                0 0 0 1px rgba(0, 0, 0, 0.1);
            transition: transform 0.15s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        /* Color picker bar */
        .color-picker-wrapper {
            position: relative;
        }

        .color-bar {
            height: 44px;
            border-radius: 22px;
            background: #007AFF;
            color: white;
            cursor: pointer;
            overflow: hidden;
            box-shadow: 
                inset 0 2px 4px rgba(0, 0, 0, 0.2),
                0 2px 8px rgba(0, 0, 0, 0.15);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 8px 0 16px;
            transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease, color 0.2s ease;
        }

        .color-bar:hover {
            transform: scale(1.02);
        }

        .color-bar:active {
            transform: scale(0.98);
        }

        .color-bar-label {
            font-size: 0.85rem;
            font-weight: 500;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        .color-bar-value {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .color-bar-hex {
            font-size: 0.75rem;
            font-family: monospace;
            opacity: 0.8;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        .color-bar-icon {
            width: 28px;
            height: 28px;
            background: rgba(255, 255, 255, 0.25);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s ease;
        }

        .color-bar-icon svg {
            width: 16px;
            height: 16px;
            fill: white;
            stroke: none;
            transition: fill 0.2s ease;
        }

        /* Hidden native color input */
        .color-input-hidden {
            position: absolute;
            opacity: 0;
            width: 0;
            height: 0;
            pointer-events: none;
        }

        /* Stats row */
        .stats-row {
            display: flex;
            justify-content: space-around;
            padding: 16px 0;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-primary);
            font-variant-numeric: tabular-nums;
        }

        .stat-label {
            font-size: 0.65rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            color: var(--text-tertiary);
            margin-top: 4px;
        }

        /* Status indicator */
        .status-indicator {
            position: fixed;
            top: 24px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 6px;
            background: var(--glass-bg);
            backdrop-filter: blur(40px) saturate(180%);
            -webkit-backdrop-filter: blur(40px) saturate(180%);
            border-radius: var(--radius-pill);
            border: 1px solid var(--glass-border);
            box-shadow: 
                0 4px 24px var(--glass-shadow),
                inset 0 1px 0 var(--glass-highlight);
        }

        .status-content {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 6px 16px 6px 12px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-tertiary);
            transition: all 0.3s ease;
        }

        .status-dot.live {
            background: #30D158;
            box-shadow: 0 0 12px rgba(48, 209, 88, 0.6);
            animation: pulse 2s ease-in-out infinite;
        }

        .status-text {
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--text-primary);
        }

        .credit-badge {
            background: rgba(255, 255, 255, 0.12);
            border: none;
            color: var(--text-secondary);
            padding: 8px 14px;
            font-family: inherit;
            font-size: 0.75rem;
            font-weight: 600;
            letter-spacing: 0.03em;
            border-radius: var(--radius-pill);
            text-decoration: none;
            transition: all 0.2s ease;
        }

        .credit-badge:hover {
            background: rgba(255, 255, 255, 0.2);
            color: var(--text-primary);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* Flash effect */
        .capture-flash {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: white;
            opacity: 0;
            pointer-events: none;
            z-index: 9999;
            transition: opacity 0.1s;
        }

        .capture-flash.flash {
            opacity: 1;
        }

        /* Responsive */
        @media (max-width: 480px) {
            .panel-expanded {
                width: calc(100vw - 32px);
                max-width: 380px;
            }

            .effect-grid {
                grid-template-columns: repeat(4, 1fr);
                gap: 6px;
            }

            .effect-btn {
                font-size: 0.55rem;
            }

            .effect-btn svg {
                width: 18px;
                height: 18px;
            }
        }
    </style>
</head>
<body>
    <div class="capture-flash" id="capture-flash"></div>

    <!-- Fullscreen video background -->
    <div class="video-background">
        <video id="video-feed" autoplay playsinline></video>
        <canvas id="canvas-output"></canvas>
    </div>

    <!-- Start Button -->
    <div class="start-container" id="start-container">
        <button class="btn-start" id="btn-start">
            <svg viewBox="0 0 24 24"><path d="M6 4l15 8-15 8V4z" fill="currentColor" stroke="none"/></svg>
            Start Camera
        </button>
    </div>

    <!-- Status indicator -->
    <div class="status-indicator" id="status-indicator">
        <a href="https://www.patrickposs.com/" target="_blank" rel="noopener" class="credit-badge">P.P.Â©'25</a>
        <div class="status-content">
            <div class="status-dot" id="status-dot"></div>
            <span class="status-text"><span id="status-text">Standby</span> â€¢ <span id="fps-display">--</span> FPS</span>
        </div>
    </div>

    <!-- Liquid Glass Control Panel -->
    <div class="control-panel" id="control-panel">
        <!-- Expanded Panel -->
        <div class="panel-expanded" id="panel-expanded">
            <div class="panel-section">
                <div class="section-header">
                    <span class="section-title">Effects</span>
                    <span class="section-value" id="current-effect">Normal</span>
                </div>
                <div class="effect-grid">
                    <button class="effect-btn active" data-effect="normal">
                        <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="9"/></svg>
                        Normal
                    </button>
                    <button class="effect-btn" data-effect="aura">
                        <svg viewBox="0 0 24 24"><path d="M12 3v18m9-9H3m15.364-6.364L5.636 18.364m12.728 0L5.636 5.636"/></svg>
                        Aura
                    </button>
                    <button class="effect-btn" data-effect="thermal">
                        <svg viewBox="0 0 24 24"><path d="M12 9v3m0 0v3m0-3h3m-3 0H9m12 0a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>
                        Thermal
                    </button>
                    <button class="effect-btn" data-effect="glitch">
                        <svg viewBox="0 0 24 24"><path d="M13 10V3L4 14h7v7l9-11h-7z"/></svg>
                        Glitch
                    </button>
                    <button class="effect-btn" data-effect="pixelate">
                        <svg viewBox="0 0 24 24"><path d="M4 5a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1H5a1 1 0 01-1-1V5zm10 0a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1h-4a1 1 0 01-1-1V5zM4 15a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1H5a1 1 0 01-1-1v-4zm10 0a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1h-4a1 1 0 01-1-1v-4z"/></svg>
                        Pixel
                    </button>
                    <button class="effect-btn" data-effect="edge">
                        <svg viewBox="0 0 24 24"><path d="M4 4l16 16M4 20L20 4"/><circle cx="12" cy="12" r="3"/></svg>
                        Edge
                    </button>
                    <button class="effect-btn" data-effect="ascii">
                        <svg viewBox="0 0 24 24"><path d="M4 7V4h16v3M9 20h6M12 4v16"/></svg>
                        ASCII
                    </button>
                    <button class="effect-btn" data-effect="mirror">
                        <svg viewBox="0 0 24 24"><path d="M12 3l9 4.5v9L12 21l-9-4.5v-9L12 3z"/></svg>
                        Kaleid
                    </button>
                </div>
            </div>

            <div class="panel-section">
                <div class="section-header">
                    <span class="section-title">Adjustments</span>
                </div>
                <div class="slider-group">
                    <div class="slider-item">
                        <div class="slider-header">
                            <span class="slider-label">Intensity</span>
                            <span class="slider-value" id="intensity-value">50%</span>
                        </div>
                        <input type="range" id="intensity" min="0" max="100" value="50">
                    </div>
                    <div class="slider-item">
                        <div class="slider-header">
                            <span class="slider-label">Brightness</span>
                            <span class="slider-value" id="brightness-value">100%</span>
                        </div>
                        <input type="range" id="brightness" min="50" max="150" value="100">
                    </div>
                    <div class="slider-item">
                        <div class="slider-header">
                            <span class="slider-label">Contrast</span>
                            <span class="slider-value" id="contrast-value">100%</span>
                        </div>
                        <input type="range" id="contrast" min="50" max="150" value="100">
                    </div>
                </div>
            </div>

            <div class="panel-section">
                <div class="section-header">
                    <span class="section-title">Color</span>
                </div>
                <div class="color-picker-wrapper">
                    <input type="color" id="color-input" class="color-input-hidden" value="#007AFF">
                    <div class="color-bar" id="color-bar">
                        <span class="color-bar-label">Accent Color</span>
                        <div class="color-bar-value">
                            <span class="color-bar-hex" id="color-hex">#007AFF</span>
                            <div class="color-bar-icon">
                                <svg viewBox="0 0 24 24">
                                    <path d="M19 3l2 2-7 7-2-2 7-7zM5 17l2 2 7-7-2-2-7 7zM3 21l2-6 4 4-6 2z"/>
                                </svg>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="stats-row">
                <div class="stat-item">
                    <div class="stat-value" id="fps-value">--</div>
                    <div class="stat-label">FPS</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="res-value">--</div>
                    <div class="stat-label">Resolution</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="frames-value">0</div>
                    <div class="stat-label">Frames</div>
                </div>
            </div>
        </div>

        <!-- Collapsed Pill Bar -->
        <div class="panel-collapsed">
            <button class="pill-btn" id="flip-btn" title="Flip Camera">
                <svg viewBox="0 0 24 24">
                    <path d="M7.5 21L3 16.5m0 0L7.5 12M3 16.5h13.5m0-13.5L21 7.5m0 0L16.5 12M21 7.5H7.5"/>
                </svg>
            </button>
            <button class="pill-btn capture-btn" id="capture-btn" title="Capture">
                <svg viewBox="0 0 24 24">
                    <circle cx="12" cy="12" r="10"/>
                </svg>
            </button>
            <button class="expand-btn" id="expand-btn" title="Settings">
                <svg viewBox="0 0 24 24">
                    <path d="M4.5 15.75l7.5-7.5 7.5 7.5"/>
                </svg>
            </button>
        </div>
    </div>

    <script>
        // State
        let stream = null;
        let cameraActive = false;
        let currentEffect = 'normal';
        let accentColor = { r: 0, g: 122, b: 255 };
        let intensity = 50;
        let brightness = 100;
        let contrast = 100;
        let frameCount = 0;
        let totalFrames = 0;
        let lastTime = performance.now();
        let fps = 0;
        let facingMode = 'user';
        let panelOpen = false;
        let noiseTime = 0;

        // Elements
        const video = document.getElementById('video-feed');
        const canvas = document.getElementById('canvas-output');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const startContainer = document.getElementById('start-container');
        const controlPanel = document.getElementById('control-panel');
        const panelExpanded = document.getElementById('panel-expanded');
        const expandBtn = document.getElementById('expand-btn');
        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');

        // Initialize canvas and start render loop immediately
        function init() {
            canvas.width = 1920;
            canvas.height = 1080;
            document.getElementById('res-value').textContent = '1920Ã—1080';
            requestAnimationFrame(processFrame);
        }

        // Generate animated noise (optimized with smaller buffer)
        function generateNoise() {
            // Use a smaller buffer for performance
            const scale = 4;
            const w = Math.ceil(canvas.width / scale);
            const h = Math.ceil(canvas.height / scale);
            
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = w;
            tempCanvas.height = h;
            
            const imageData = tempCtx.createImageData(w, h);
            const data = imageData.data;
            noiseTime += 0.02;

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const i = (y * w + x) * 4;
                    
                    // Flowing noise with multiple frequencies
                    const nx = x * 0.02;
                    const ny = y * 0.02;
                    
                    const wave1 = Math.sin(nx + noiseTime) * Math.cos(ny + noiseTime * 0.7);
                    const wave2 = Math.sin(nx * 2.5 - noiseTime * 1.3) * Math.cos(ny * 2.5 + noiseTime * 0.5);
                    const grain = (Math.random() - 0.5) * 0.3;
                    
                    const combined = (wave1 * 0.6 + wave2 * 0.3 + grain * 0.1) * 0.5 + 0.5;
                    const value = Math.floor(combined * 35 + 8);
                    
                    data[i] = value;
                    data[i + 1] = value;
                    data[i + 2] = value + Math.floor(combined * 15); // Blue tint
                    data[i + 3] = 255;
                }
            }
            
            tempCtx.putImageData(imageData, 0, 0);
            
            // Scale up to full canvas
            ctx.imageSmoothingEnabled = true;
            ctx.drawImage(tempCanvas, 0, 0, canvas.width, canvas.height);
        }

        // Initialize camera
        async function startCamera() {
            try {
                stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 1920 },
                        height: { ideal: 1080 },
                        facingMode: facingMode
                    }
                });

                video.srcObject = stream;
                video.style.display = 'block';
                startContainer.classList.add('hidden');
                statusDot.classList.add('live');
                statusText.textContent = 'Live';

                video.onloadedmetadata = () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    document.getElementById('res-value').textContent =
                        `${video.videoWidth}Ã—${video.videoHeight}`;
                    cameraActive = true;
                };
            } catch (err) {
                console.error('Camera access denied:', err);
                alert('Camera access is required for this application.');
            }
        }

        // Start on load
        init();

        document.getElementById('btn-start').addEventListener('click', (e) => {
            // Only trigger if not dragging
            if (!isDragging && !wasDragged) {
                startCamera();
            }
        });

        // Draggable button with physics
        const btnStart = document.getElementById('btn-start');
        const statusIndicator = document.getElementById('status-indicator');
        const controlPanelEl = document.getElementById('control-panel');
        let isDragging = false;
        let wasDragged = false;
        let dragStartX, dragStartY, initialX, initialY;
        let velocityX = 0, velocityY = 0;
        let dragLastX, dragLastY, dragLastTime;
        let animationId = null;
        let posX = window.innerWidth / 2;
        let posY = window.innerHeight / 2;
        const btnRadius = 100;
        const padding = 20;

        // Get safe bounds (avoiding UI elements)
        function getSafeBounds() {
            const statusRect = statusIndicator.getBoundingClientRect();
            const collapsedBar = document.querySelector('.panel-collapsed');
            const barRect = collapsedBar.getBoundingClientRect();
            
            // Use sensible defaults if elements aren't laid out yet
            const topBound = (statusRect.height > 0) 
                ? statusRect.bottom + btnRadius + padding 
                : btnRadius + 80;
            
            const bottomBound = (barRect.top > 0 && barRect.top < window.innerHeight) 
                ? barRect.top - btnRadius - padding 
                : window.innerHeight - btnRadius - 80;
            
            return {
                left: btnRadius + padding,
                right: window.innerWidth - btnRadius - padding,
                top: topBound,
                bottom: Math.max(bottomBound, topBound + 100) // Ensure there's always room
            };
        }

        // Clamp position to safe bounds
        function clampPosition() {
            const bounds = getSafeBounds();
            posX = Math.max(bounds.left, Math.min(bounds.right, posX));
            posY = Math.max(bounds.top, Math.min(bounds.bottom, posY));
        }

        // Initialize position
        function updateButtonPosition() {
            btnStart.style.left = posX + 'px';
            btnStart.style.top = posY + 'px';
            btnStart.style.transform = 'translate(-50%, -50%)';
        }
        
        // Set initial position after a brief delay to ensure layout is complete
        requestAnimationFrame(() => {
            posX = window.innerWidth / 2;
            posY = window.innerHeight / 2;
            clampPosition();
            updateButtonPosition();
        });

        function onDragStart(e) {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            
            isDragging = true;
            wasDragged = false;
            btnStart.classList.add('dragging');
            
            const point = e.touches ? e.touches[0] : e;
            dragStartX = point.clientX;
            dragStartY = point.clientY;
            initialX = posX;
            initialY = posY;
            dragLastX = dragStartX;
            dragLastY = dragStartY;
            dragLastTime = Date.now();
            velocityX = 0;
            velocityY = 0;
        }

        function onDragMove(e) {
            if (!isDragging) return;
            e.preventDefault();
            
            const point = e.touches ? e.touches[0] : e;
            const dx = point.clientX - dragStartX;
            const dy = point.clientY - dragStartY;
            
            // Mark as dragged if moved more than 5px
            if (Math.abs(dx) > 5 || Math.abs(dy) > 5) {
                wasDragged = true;
            }
            
            posX = initialX + dx;
            posY = initialY + dy;
            
            // Clamp to safe bounds while dragging
            clampPosition();
            
            // Calculate velocity
            const now = Date.now();
            const dt = now - dragLastTime;
            if (dt > 0) {
                velocityX = (point.clientX - dragLastX) / dt * 16;
                velocityY = (point.clientY - dragLastY) / dt * 16;
            }
            dragLastX = point.clientX;
            dragLastY = point.clientY;
            dragLastTime = now;
            
            updateButtonPosition();
        }

        function onDragEnd() {
            if (!isDragging) return;
            isDragging = false;
            btnStart.classList.remove('dragging');
            
            // Start physics animation if there's velocity
            if (Math.abs(velocityX) > 0.5 || Math.abs(velocityY) > 0.5) {
                animatePhysics();
            }
            
            // Reset wasDragged after a short delay to allow click to be blocked
            setTimeout(() => {
                wasDragged = false;
            }, 100);
        }

        function animatePhysics() {
            const friction = 0.95;
            const bounce = 0.6;
            const bounds = getSafeBounds();
            
            velocityX *= friction;
            velocityY *= friction;
            
            posX += velocityX;
            posY += velocityY;
            
            // Bounce off safe bounds
            if (posX < bounds.left) {
                posX = bounds.left;
                velocityX *= -bounce;
            } else if (posX > bounds.right) {
                posX = bounds.right;
                velocityX *= -bounce;
            }
            
            if (posY < bounds.top) {
                posY = bounds.top;
                velocityY *= -bounce;
            } else if (posY > bounds.bottom) {
                posY = bounds.bottom;
                velocityY *= -bounce;
            }
            
            updateButtonPosition();
            
            // Continue animation if still moving
            if (Math.abs(velocityX) > 0.1 || Math.abs(velocityY) > 0.1) {
                animationId = requestAnimationFrame(animatePhysics);
            }
        }

        // Mouse events
        btnStart.addEventListener('mousedown', onDragStart);
        document.addEventListener('mousemove', onDragMove);
        document.addEventListener('mouseup', onDragEnd);

        // Touch events
        btnStart.addEventListener('touchstart', onDragStart, { passive: false });
        document.addEventListener('touchmove', onDragMove, { passive: false });
        document.addEventListener('touchend', onDragEnd);

        // Handle window resize
        window.addEventListener('resize', () => {
            clampPosition();
            updateButtonPosition();
        });

        // Panel expand/collapse
        expandBtn.addEventListener('click', () => {
            panelOpen = !panelOpen;
            panelExpanded.classList.toggle('open', panelOpen);
            expandBtn.classList.toggle('open', panelOpen);
        });

        // Close panel when clicking outside
        document.addEventListener('click', (e) => {
            if (panelOpen && !e.target.closest('.control-panel')) {
                panelOpen = false;
                panelExpanded.classList.remove('open');
                expandBtn.classList.remove('open');
            }
        });

        // Flip camera
        document.getElementById('flip-btn').addEventListener('click', async () => {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                cameraActive = false;
            }
            facingMode = facingMode === 'user' ? 'environment' : 'user';
            await startCamera();
        });

        // Effect buttons
        document.querySelectorAll('.effect-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.effect-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentEffect = btn.dataset.effect;
                document.getElementById('current-effect').textContent =
                    currentEffect.charAt(0).toUpperCase() + currentEffect.slice(1);
            });
        });

        // Color picker
        const colorInput = document.getElementById('color-input');
        const colorBar = document.getElementById('color-bar');
        const colorHex = document.getElementById('color-hex');

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 122, b: 255 };
        }

        function getLuminance(r, g, b) {
            return (0.299 * r + 0.587 * g + 0.114 * b) / 255;
        }

        function updateColorBar(hex) {
            colorBar.style.background = hex;
            colorHex.textContent = hex.toUpperCase();
            accentColor = hexToRgb(hex);
            
            // Adjust text color based on background luminance
            const luminance = getLuminance(accentColor.r, accentColor.g, accentColor.b);
            const textColor = luminance > 0.5 ? 'rgba(0,0,0,0.8)' : 'rgba(255,255,255,0.95)';
            const iconBg = luminance > 0.5 ? 'rgba(0,0,0,0.15)' : 'rgba(255,255,255,0.25)';
            
            colorBar.style.color = textColor;
            colorBar.querySelector('.color-bar-icon').style.background = iconBg;
            colorBar.querySelector('.color-bar-icon svg').style.fill = textColor;
        }

        colorBar.addEventListener('click', () => {
            colorInput.click();
        });

        colorInput.addEventListener('input', (e) => {
            updateColorBar(e.target.value);
        });

        // Initialize color bar
        updateColorBar('#007AFF');

        // Sliders
        document.getElementById('intensity').addEventListener('input', (e) => {
            intensity = parseInt(e.target.value);
            document.getElementById('intensity-value').textContent = intensity + '%';
        });

        document.getElementById('brightness').addEventListener('input', (e) => {
            brightness = parseInt(e.target.value);
            document.getElementById('brightness-value').textContent = brightness + '%';
        });

        document.getElementById('contrast').addEventListener('input', (e) => {
            contrast = parseInt(e.target.value);
            document.getElementById('contrast-value').textContent = contrast + '%';
        });

        // Capture button
        document.getElementById('capture-btn').addEventListener('click', () => {
            const flash = document.getElementById('capture-flash');
            flash.classList.add('flash');
            setTimeout(() => flash.classList.remove('flash'), 100);

            const link = document.createElement('a');
            link.download = `vision-${Date.now()}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        });

        // Main processing loop
        function processFrame() {
            frameCount++;
            totalFrames++;
            const now = performance.now();
            if (now - lastTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastTime = now;
                document.getElementById('fps-value').textContent = fps;
                document.getElementById('fps-display').textContent = fps;
            }
            document.getElementById('frames-value').textContent = totalFrames;

            // Draw source: either camera or animated noise
            if (cameraActive && stream) {
                ctx.save();
                if (facingMode === 'user') {
                    ctx.scale(-1, 1);
                    ctx.drawImage(video, -canvas.width, 0, canvas.width, canvas.height);
                } else {
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                }
                ctx.restore();
            } else {
                generateNoise();
            }

            // Brightness/contrast
            if (brightness !== 100 || contrast !== 100) {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                
                // Convert contrast from 50-150 range to -127.5 to 127.5 range (where 0 = no change)
                const contrastAdjusted = (contrast - 100) * 2.55;
                const factor = (259 * (contrastAdjusted + 255)) / (255 * (259 - contrastAdjusted));
                const brightnessAdjusted = brightness / 100;

                for (let i = 0; i < data.length; i += 4) {
                    // Apply brightness first, then contrast
                    data[i] = clamp(factor * (data[i] * brightnessAdjusted - 128) + 128);
                    data[i + 1] = clamp(factor * (data[i + 1] * brightnessAdjusted - 128) + 128);
                    data[i + 2] = clamp(factor * (data[i + 2] * brightnessAdjusted - 128) + 128);
                }
                ctx.putImageData(imageData, 0, 0);
            }

            // Apply effect
            switch (currentEffect) {
                case 'aura': applyAura(); break;
                case 'thermal': applyThermal(); break;
                case 'glitch': applyGlitch(); break;
                case 'pixelate': applyPixelate(); break;
                case 'edge': applyEdgeDetection(); break;
                case 'ascii': applyAscii(); break;
                case 'mirror': applyKaleidoscope(); break;
            }

            requestAnimationFrame(processFrame);
        }

        function clamp(val) {
            return Math.max(0, Math.min(255, val));
        }

        function applyAura() {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const strength = intensity / 100;

            for (let i = 0; i < data.length; i += 4) {
                const luminance = (data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114) / 255;
                const auraStrength = Math.pow(luminance, 2) * strength;

                data[i] = clamp(data[i] + accentColor.r * auraStrength * 0.5);
                data[i + 1] = clamp(data[i + 1] + accentColor.g * auraStrength * 0.5);
                data[i + 2] = clamp(data[i + 2] + accentColor.b * auraStrength * 0.5);
            }

            ctx.putImageData(imageData, 0, 0);

            ctx.globalCompositeOperation = 'screen';
            ctx.fillStyle = `rgba(${accentColor.r}, ${accentColor.g}, ${accentColor.b}, ${0.1 * strength})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.globalCompositeOperation = 'source-over';
        }

        function applyThermal() {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const strength = intensity / 100;

            for (let i = 0; i < data.length; i += 4) {
                const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                const normalized = avg / 255;

                let r, g, b;
                if (normalized < 0.25) {
                    r = 0; g = normalized * 4 * 255; b = 255;
                } else if (normalized < 0.5) {
                    r = 0; g = 255; b = (1 - (normalized - 0.25) * 4) * 255;
                } else if (normalized < 0.75) {
                    r = (normalized - 0.5) * 4 * 255; g = 255; b = 0;
                } else {
                    r = 255; g = (1 - (normalized - 0.75) * 4) * 255; b = 0;
                }

                data[i] = clamp(data[i] * (1 - strength) + r * strength);
                data[i + 1] = clamp(data[i + 1] * (1 - strength) + g * strength);
                data[i + 2] = clamp(data[i + 2] * (1 - strength) + b * strength);
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function applyGlitch() {
            const strength = intensity / 100;
            const sliceCount = Math.floor(5 + strength * 15);

            for (let i = 0; i < sliceCount; i++) {
                if (Math.random() > 0.7) {
                    const y = Math.random() * canvas.height;
                    const height = Math.random() * 30 + 5;
                    const offset = (Math.random() - 0.5) * 50 * strength;

                    const slice = ctx.getImageData(0, y, canvas.width, height);
                    ctx.putImageData(slice, offset, y);
                }
            }

            if (Math.random() > 0.5) {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                const shift = Math.floor(strength * 10);

                for (let y = 0; y < canvas.height; y++) {
                    for (let x = 0; x < canvas.width; x++) {
                        const i = (y * canvas.width + x) * 4;
                        const shiftedI = (y * canvas.width + Math.min(x + shift, canvas.width - 1)) * 4;
                        data[i] = data[shiftedI];
                    }
                }
                ctx.putImageData(imageData, 0, 0);
            }
        }

        function applyPixelate() {
            const size = Math.max(2, Math.floor(2 + (intensity / 100) * 30));

            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = Math.ceil(canvas.width / size);
            tempCanvas.height = Math.ceil(canvas.height / size);

            tempCtx.drawImage(canvas, 0, 0, tempCanvas.width, tempCanvas.height);
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(tempCanvas, 0, 0, canvas.width, canvas.height);
            ctx.imageSmoothingEnabled = true;
        }

        function applyEdgeDetection() {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
            const output = new Uint8ClampedArray(data.length);
            const strength = intensity / 100;

            const sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
            const sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];

            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    let gx = 0, gy = 0;

                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const idx = ((y + ky) * width + (x + kx)) * 4;
                            const gray = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                            const ki = (ky + 1) * 3 + (kx + 1);
                            gx += gray * sobelX[ki];
                            gy += gray * sobelY[ki];
                        }
                    }

                    const magnitude = Math.sqrt(gx * gx + gy * gy);
                    const i = (y * width + x) * 4;

                    const edgeVal = clamp(magnitude * strength);
                    output[i] = data[i] * (1 - strength) + (accentColor.r * edgeVal / 255) * strength;
                    output[i + 1] = data[i + 1] * (1 - strength) + (accentColor.g * edgeVal / 255) * strength;
                    output[i + 2] = data[i + 2] * (1 - strength) + (accentColor.b * edgeVal / 255) * strength;
                    output[i + 3] = 255;
                }
            }

            ctx.putImageData(new ImageData(output, width, height), 0, 0);
        }

        function applyAscii() {
            const chars = ' .:-=+*#%@';
            const fontSize = Math.max(4, 16 - Math.floor(intensity / 10));

            // Store current canvas content
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            tempCtx.drawImage(canvas, 0, 0);

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const cols = Math.floor(canvas.width / fontSize);
            const rows = Math.floor(canvas.height / fontSize);

            ctx.font = `${fontSize}px monospace`;
            ctx.fillStyle = `rgb(${accentColor.r}, ${accentColor.g}, ${accentColor.b})`;
            ctx.textBaseline = 'top';

            const imageData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const px = Math.floor(x * fontSize + fontSize / 2);
                    const py = Math.floor(y * fontSize + fontSize / 2);
                    const i = (py * canvas.width + px) * 4;

                    const bright = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    const charIndex = Math.floor((bright / 255) * (chars.length - 1));

                    ctx.fillText(chars[charIndex], x * fontSize, y * fontSize);
                }
            }
        }

        function applyKaleidoscope() {
            const segments = Math.max(4, Math.floor(4 + (intensity / 100) * 12));
            const angleStep = (Math.PI * 2) / segments;
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;

            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            tempCtx.drawImage(canvas, 0, 0);

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            for (let i = 0; i < segments; i++) {
                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(angleStep * i);

                if (i % 2 === 1) {
                    ctx.scale(-1, 1);
                }

                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.arc(0, 0, Math.max(cx, cy) * 1.5, -angleStep / 2, angleStep / 2);
                ctx.closePath();
                ctx.clip();

                ctx.drawImage(tempCanvas, -cx, -cy);
                ctx.restore();
            }

            ctx.globalCompositeOperation = 'overlay';
            ctx.fillStyle = `rgba(${accentColor.r}, ${accentColor.g}, ${accentColor.b}, 0.1)`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.globalCompositeOperation = 'source-over';
        }
    </script>
</body>
</html>
